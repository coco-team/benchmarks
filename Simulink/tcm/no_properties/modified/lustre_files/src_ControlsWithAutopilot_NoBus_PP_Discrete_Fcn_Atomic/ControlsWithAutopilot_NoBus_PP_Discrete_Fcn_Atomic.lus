-- This file has been generated by CoCoSim



-- Trig function using interpolation
 node __sin(x:real) returns (out:real);
let
out = if (0.0<=x and x<=0.15707963267948965579) then 0.0 + (0.99589273524356136668 * (x - 0.0)) else 
      if (0.15707963267948965579<=x and x<=0.31415926535897931159) then 0.15643446504023086895 + (0.97137055092337043493 * (x - 0.15707963267948965579)) else 
      if (0.31415926535897931159<=x and x<=0.47123889803846896739) then 0.30901699437494739575 + (0.92292999984541579383 * (x - 0.31415926535897931159)) else 
      if (0.47123889803846896739<=x and x<=0.62831853071795862319) then 0.45399049973954674896 + (0.85176384914220870658 * (x - 0.47123889803846896739)) else 
      if (0.62831853071795862319<=x and x<=0.78539816339744827899) then 0.58778525229247313710 + (0.75962444563097375471 * (x - 0.62831853071795862319)) else 
      if (0.78539816339744827899<=x and x<=0.94247779607693793479) then 0.70710678118654746171 + (0.64878056721930821293 * (x - 0.78539816339744827899)) else 
      if (0.94247779607693793479<=x and x<=1.09955742875642759059) then 0.80901699437494734024 + (0.52196155806344746164 * (x - 0.94247779607693793479)) else 
      if (1.09955742875642759059<=x and x<=1.25663706143591724639) then 0.89100652418836778778 + (0.38229012305696996598 * (x - 1.09955742875642759059)) else 
      if (1.25663706143591724639<=x and x<=1.41371669411540690219) then 0.95105651629515353118 + (0.23320543647265201681 * (x - 1.25663706143591724639)) else 
      if (1.41371669411540690219<=x and x<=1.57079632679489655799) then 0.98768834059513777035 + (0.07837845807790584651 * (x - 1.41371669411540690219)) else -1.0;
tel

node sin(x:real) returns (out:real);
let
out = if (0.0<=x and x<=1.57079632679489655799) then __sin(x) else 
      if (1.57079632679489655799<=x and x<=3.14159265358979311599) then __sin(3.14159265358979311599-x) else 
      if (3.14159265358979311599<=x and x<=4.71238898038468967399) then -(__sin(x - 3.14159265358979311599)) else 
      if (4.71238898038468967399<=x and x<=6.28318530717958623199) then -(__sin(6.28318530717958623199 - x))  else -1.0;
tel

node cos(x:real) returns (out:real);
let
out = if (0.0<=x and x<=4.71238898038468967399) then sin(1.57079632679489655799 + x) else 
      if (4.71238898038468967399<=x and x<=6.28318530717958623199) then sin(x - 4.71238898038468967399) else -1.0;
tel

node __asin(x:real) returns (out:real);
let
out = if (0.0<=x and x<=0.15643446504023086895) then 0.0 + (1.00412420395398727102 * (x - 0.0)) else 
      if (0.15643446504023086895<=x and x<=0.30901699437494739575) then 0.15707963267948965579 + (1.02947325204517969865 * (x - 0.15643446504023086895)) else 
      if (0.30901699437494739575<=x and x<=0.45399049973954674896) then 0.31415926535897931159 + (1.08350579151993375859 * (x - 0.30901699437494739575)) else 
      if (0.45399049973954674896<=x and x<=0.58778525229247313710) then 0.47123889803846891188 + (1.17403433006352253542 * (x - 0.45399049973954674896)) else 
      if (0.58778525229247313710<=x and x<=0.70710678118654746171) then 0.62831853071795862319 + (1.31643999314603443728 * (x - 0.58778525229247313710)) else 
      if (0.70710678118654746171<=x and x<=0.80901699437494734024) then 0.78539816339744816797 + (1.54135319478822885308 * (x - 0.70710678118654746171)) else 
      if (0.80901699437494734024<=x and x<=0.89100652418836778778) then 0.94247779607693782377 + (1.91584990226127604984 * (x - 0.80901699437494734024)) else 
      if (0.89100652418836778778<=x and x<=0.95105651629515353118) then 1.09955742875642736855 + (2.61581437679722261790 * (x - 0.89100652418836778778)) else 
      if (0.95105651629515353118<=x and x<=0.98768834059513777035) then 1.25663706143591724639 + (4.28806470005802253808 * (x - 0.95105651629515353118)) else 
      if (0.98768834059513777035<=x and x<=1.0) then 1.41371669411540734628 + (12.75860771598781617797 * (x - 0.98768834059513777035)) else -1.0;
tel

node asin(x:real) returns (out:real);
let
out = if (-1.0<=x and x<=0.0) then -(__asin(-x)) else 
      if (0.0<=x and x<=1.0) then __asin(x) else -1.0;
tel

node acos(x:real) returns (out:real);
let
out = 1.57079632679489655799-asin(x);
tel

node __atan(x:real) returns (out:real);
let
out = if (0.0<=x and x<=0.69813170079773179121) then 0.0 + (0.87300285996325233117 * (x - 0.0)) else 
      if (0.69813170079773179121<=x and x<=1.39626340159546358243) then 0.60947097142742945319 + (0.48674379118670563215 * (x - 0.69813170079773179121)) else 
      if (1.39626340159546358243<=x and x<=2.09439510239319526263) then 0.94928224222134027776 + (0.25218249001124593000 * (x - 1.39626340159546358243)) else 
      if (2.09439510239319526263<=x and x<=2.79252680319092716487) then 1.12533883288429836788 + (0.14551146078247279014 * (x - 2.09439510239319526263)) else 
      if (2.79252680319092716487<=x and x<=3.49065850398865906711) then 1.22692499648592856509 + (0.09291213792183362907 * (x - 2.79252680319092716487)) else 
      if (3.49065850398865906711<=x and x<=4.18879020478639052527) then 1.29178990535805171546 + (0.06397121617235962398 * (x - 3.49065850398865906711)) else 
      if (4.18879020478639052527<=x and x<=4.88692190558412242751) then 1.33645023930656048349 + (0.04655958355337140586 * (x - 4.18879020478639052527)) else 
      if (4.88692190558412242751<=x and x<=5.58505360638185432975) then 1.36895496056110976823 + (0.03533636095655147413 * (x - 4.88692190558412242751)) else 
      if (5.58505360638185432975<=x and x<=6.28318530717958623199) then 1.39362439433570961533 + (0.02770357247626497806 * (x - 5.58505360638185432975)) else 
      if (6.28318530717958623199<=x and x<=1608.49543863797407539095) then 1.41296513650673771778 + (0.00009812026530504006 * (x - 6.28318530717958623199)) else 1.57079632679489655799;
tel

node atan(x:real) returns (out:real);
let
out = if (x>=0.0) then __atan(x) else -(__atan(-x));
tel

node atan2(y:real; x:real) returns (out:real);
let
out = if (x>0.0) then atan(y/x) else 
    if (x<0.0) then 
      if (y>=0.0) then atan(y/x) + 3.14159265358979311599 else atan(y/x) - 3.14159265358979311599 else 
    if (y>0.0) then 1.57079632679489655799 else 
    if (y<0.0) then -1.57079632679489655799 else 0.0;
tel

node __tan(x:real) returns (out:real);
let
out = if (0.0<=x and x<=0.15707963267948965579) then 0.0 + (1.00830666345973063435 * (x - 0.0)) else 
      if (0.15707963267948965579<=x and x<=0.31415926535897931159) then 0.15838444032453627419 + (1.06019636707563424948 * (x - 0.15707963267948965579)) else 
      if (0.31415926535897931159<=x and x<=0.47123889803846896739) then 0.32491969623290628543 + (1.17523672619096353209 * (x - 0.31415926535897931159)) else 
      if (0.47123889803846896739<=x and x<=0.62831853071795862319) then 0.50952544949442879484 + (1.38157363121507126280 * (x - 0.47123889803846896739)) else 
      if (0.62831853071795862319<=x and x<=0.78539816339744827899) then 0.72654252800536089917 + (1.74088433573441325741 * (x - 0.62831853071795862319)) else 
      if (0.78539816339744827899<=x and x<=0.94247779607693793479) then 0.99999999999999988897 + (2.39612172533631406778 * (x - 0.78539816339744827899)) else 
      if (0.94247779607693793479<=x and x<=1.09955742875642759059) then 1.37638192047117313698 + (3.73204708359699921516 * (x - 0.94247779607693793479)) else 
      if (1.09955742875642759059<=x and x<=1.25663706143591724639) then 1.96261050550515037116 + (7.09877539595049622533 * (x - 1.09955742875642759059)) else 
      if (1.25663706143591724639<=x and x<=1.41371669411540690219) then 3.07768353717525311452 + (20.60144859201934508519 * (x - 1.25663706143591724639)) else 
      if (1.41371669411540690219<=x and x<=1.57079632679489655799) then 6.31375151467504114322 + (103967898795117200.0 * (x - 1.41371669411540690219)) else -1.0;
tel

node tan(x:real) returns (out:real);
let
out = if (0.0<=x and x<=1.57079632679489655799) then __tan(x) else 
      if (1.57079632679489655799<=x and x<=3.14159265358979311599) then -(__tan(3.14159265358979311599-x)) else 
      if (3.14159265358979311599<=x and x<=4.71238898038468967399) then __tan(x - 3.14159265358979311599) else 
      if (4.71238898038468967399<=x and x<=6.28318530717958623199) then -(__tan(6.28318530717958623199 - x))  else -1.0;
tel


 -- End trig function
-- System nodes
node ControlsWithAutopilot_NoBus_PP_Discrete_Fcn_Atomic_YawDamper_YD_wo_pp (Inport1_1_1 : real)
returns (Outport1_1_1 : real); 
var
	D1_1_1 : real;
	GainAC1_1_1_1 : real;
	GainAC2_1_1_1 : real;
	GainBD1_1_1_1 : real;
	GainBD2_1_1_1 : real;
	Sum1_1_1 : real;
	Sum2_1_1 : real;
let 
	D1_1_1 = 0.00000000 -> pre Sum1_1_1;
	GainAC1_1_1_1 = -10.00000000 * D1_1_1;
	GainAC2_1_1_1 = -10.00000000 * D1_1_1;
	GainBD1_1_1_1 = 1.00000000 * Inport1_1_1;
	GainBD2_1_1_1 = 1.00000000 * Inport1_1_1;
	Sum1_1_1 = GainAC1_1_1_1 + GainBD1_1_1_1;
	Sum2_1_1 = GainAC2_1_1_1 + GainBD2_1_1_1;
	Outport1_1_1 = Sum2_1_1;
tel

node ControlsWithAutopilot_NoBus_PP_Discrete_Fcn_Atomic_YawDamper_Kcas_pp (In_1_1 : real)
returns (Out_1_1 : real); 
var
	CompInfEq2_1_1 : bool;
	CompInfEq3_1_1 : bool;
	CompInfEq4_1_1 : bool;
	CompSup1_1_1 : bool;
	CompSup2_1_1 : bool;
	CompSup3_1_1 : bool;
	Data1_1_1 : real;
	Data2_1_1 : real;
	Data3_1_1 : real;
	Data4_1_1 : real;
	Idx1_1_1 : real;
	Idx2_1_1 : real;
	Idx3_1_1 : real;
	Idx4_1_1 : real;
	Product1_1_1 : real;
	Product2_1_1 : real;
	Product3_1_1 : real;
	Interpolate3_Interpolate_1_1 : real;
	Interpolate3_Sum1_1_1 : real;
	Interpolate3_Sum2_1_1 : real;
	Interpolate3_Sum3_1_1 : real;
	Interpolate3_Sum4_1_1 : real;
	Interpolate2_Interpolate_1_1 : real;
	Interpolate2_Sum1_1_1 : real;
	Interpolate2_Sum2_1_1 : real;
	Interpolate2_Sum3_1_1 : real;
	Interpolate2_Sum4_1_1 : real;
	Interpolate1_Interpolate_1_1 : real;
	Interpolate1_Sum1_1_1 : real;
	Interpolate1_Sum2_1_1 : real;
	Interpolate1_Sum3_1_1 : real;
	Interpolate1_Sum4_1_1 : real;
	Sum_1_1 : real;
let 
	CompInfEq2_1_1 = In_1_1 <= Idx2_1_1;
	CompInfEq3_1_1 = In_1_1 <= Idx3_1_1;
	CompInfEq4_1_1 = In_1_1 <= Idx4_1_1;
	CompSup1_1_1 = In_1_1 >= Idx1_1_1;
	CompSup2_1_1 = In_1_1 > Idx2_1_1;
	CompSup3_1_1 = In_1_1 > Idx3_1_1;
	Data1_1_1 = 1.00000000;
	Data2_1_1 = 1.00000000;
	Data3_1_1 = 0.30000000;
	Data4_1_1 = 0.30000000;
	Idx1_1_1 = 0.00000000;
	Idx2_1_1 = 120.00000000;
	Idx3_1_1 = 350.00000000;
	Idx4_1_1 = 500.00000000;
	Product1_1_1 = Interpolate1_Sum4_1_1 * (if CompSup1_1_1 then 1.0 else 0.0) * (if CompInfEq2_1_1 then 1.0 else 0.0);
	Product2_1_1 = Interpolate2_Sum4_1_1 * (if CompSup2_1_1 then 1.0 else 0.0) * (if CompInfEq3_1_1 then 1.0 else 0.0);
	Product3_1_1 = Interpolate3_Sum4_1_1 * (if CompSup3_1_1 then 1.0 else 0.0) * (if CompInfEq4_1_1 then 1.0 else 0.0);
	Interpolate3_Interpolate_1_1 = Interpolate3_Sum1_1_1 / Interpolate3_Sum2_1_1 * Interpolate3_Sum3_1_1;
	Interpolate3_Sum1_1_1 = In_1_1 - Idx3_1_1;
	Interpolate3_Sum2_1_1 =  - Idx3_1_1 + Idx4_1_1;
	Interpolate3_Sum3_1_1 =  - Data3_1_1 + Data4_1_1;
	Interpolate3_Sum4_1_1 = Interpolate3_Interpolate_1_1 + Data3_1_1;
	Interpolate2_Interpolate_1_1 = Interpolate2_Sum1_1_1 / Interpolate2_Sum2_1_1 * Interpolate2_Sum3_1_1;
	Interpolate2_Sum1_1_1 = In_1_1 - Idx2_1_1;
	Interpolate2_Sum2_1_1 =  - Idx2_1_1 + Idx3_1_1;
	Interpolate2_Sum3_1_1 =  - Data2_1_1 + Data3_1_1;
	Interpolate2_Sum4_1_1 = Interpolate2_Interpolate_1_1 + Data2_1_1;
	Interpolate1_Interpolate_1_1 = Interpolate1_Sum1_1_1 / Interpolate1_Sum2_1_1 * Interpolate1_Sum3_1_1;
	Interpolate1_Sum1_1_1 = In_1_1 - Idx1_1_1;
	Interpolate1_Sum2_1_1 =  - Idx1_1_1 + Idx2_1_1;
	Interpolate1_Sum3_1_1 =  - Data1_1_1 + Data2_1_1;
	Interpolate1_Sum4_1_1 = Interpolate1_Interpolate_1_1 + Data1_1_1;
	Sum_1_1 = Product1_1_1 + Product2_1_1 + Product3_1_1;
	Out_1_1 = Sum_1_1;
tel

node ControlsWithAutopilot_NoBus_PP_Discrete_Fcn_Atomic_YawDamper (rdeg_1_1 : real; CAS_1_1 : real; PedalRud_1_1 : real; PedalRud_1_2 : real; Engage_1_1 : real)
returns (RudCmd_1_1 : real; RudCmd_1_2 : real;
	DamperCmd_2_1 : real); 
var
	Kcas_pp_1_1 : real;
	Kr_1_1 : real;
	Product_1_1 : real;
	ManualOverride_Switch1_1_1 : real; ManualOverride_Switch1_1_2 : real;
	EngageORzero_LogicalOperator5_1_1 : bool;
	EngageORzero_Switch1_1_1 : real;
	EngageORzero_zero10_1_1 : real;
	EngageORzero_zero9_1_1 : real;
	YD_wo_pp_1_1 : real;
let 
	Kcas_pp_1_1 = ControlsWithAutopilot_NoBus_PP_Discrete_Fcn_Atomic_YawDamper_Kcas_pp(CAS_1_1);
	Kr_1_1 = 1.25000000 * rdeg_1_1;
	Product_1_1 = YD_wo_pp_1_1 * Kcas_pp_1_1;
	ManualOverride_Switch1_1_1 = if not(PedalRud_1_2 = 0.0) then EngageORzero_Switch1_1_1 else PedalRud_1_2;
	ManualOverride_Switch1_1_2 = if not(PedalRud_1_2 = 0.0) then EngageORzero_Switch1_1_1 else PedalRud_1_2;
	EngageORzero_LogicalOperator5_1_1 = (Engage_1_1 != 0.0) and (EngageORzero_zero10_1_1 != 0.0);
	EngageORzero_Switch1_1_1 = if (if EngageORzero_LogicalOperator5_1_1 then 1.0 else 0.0) >= 0.50000000 then Product_1_1 else EngageORzero_zero9_1_1;
	EngageORzero_zero10_1_1 = 1.00000000;
	EngageORzero_zero9_1_1 = 0.00000000;
	YD_wo_pp_1_1 = ControlsWithAutopilot_NoBus_PP_Discrete_Fcn_Atomic_YawDamper_YD_wo_pp(Kr_1_1);
	RudCmd_1_1 = ManualOverride_Switch1_1_1;
	RudCmd_1_2 = ManualOverride_Switch1_1_2;
	DamperCmd_2_1 = EngageORzero_Switch1_1_1;
tel

node ControlsWithAutopilot_NoBus_PP_Discrete_Fcn_Atomic_Longitudinal_PitchInnerLoop_TransferFcn_pp (Inport1_1_1 : real)
returns (Outport1_1_1 : real); 
var
	D1_1_1 : real;
	GainAC1_1_1_1 : real;
	GainAC2_1_1_1 : real;
	GainBD1_1_1_1 : real;
	GainBD2_1_1_1 : real;
	Sum1_1_1 : real;
	Sum2_1_1 : real;
let 
	D1_1_1 = 0.00000000 -> pre Sum1_1_1;
	GainAC1_1_1_1 = -0.06250000 * D1_1_1;
	GainAC2_1_1_1 = -0.06250000 * D1_1_1;
	GainBD1_1_1_1 = 1.00000000 * Inport1_1_1;
	GainBD2_1_1_1 = 1.00000000 * Inport1_1_1;
	Sum1_1_1 = GainAC1_1_1_1 + GainBD1_1_1_1;
	Sum2_1_1 = GainAC2_1_1_1 + GainBD2_1_1_1;
	Outport1_1_1 = Sum2_1_1;
tel

node ControlsWithAutopilot_NoBus_PP_Discrete_Fcn_Atomic_Longitudinal_PitchInnerLoop_Kcas_pp (In_1_1 : real)
returns (Out_1_1 : real); 
var
	CompInfEq2_1_1 : bool;
	CompInfEq3_1_1 : bool;
	CompInfEq4_1_1 : bool;
	CompSup1_1_1 : bool;
	CompSup2_1_1 : bool;
	CompSup3_1_1 : bool;
	Data1_1_1 : real;
	Data2_1_1 : real;
	Data3_1_1 : real;
	Data4_1_1 : real;
	Idx1_1_1 : real;
	Idx2_1_1 : real;
	Idx3_1_1 : real;
	Idx4_1_1 : real;
	Product1_1_1 : real;
	Product2_1_1 : real;
	Product3_1_1 : real;
	Interpolate3_Interpolate_1_1 : real;
	Interpolate3_Sum1_1_1 : real;
	Interpolate3_Sum2_1_1 : real;
	Interpolate3_Sum3_1_1 : real;
	Interpolate3_Sum4_1_1 : real;
	Interpolate2_Interpolate_1_1 : real;
	Interpolate2_Sum1_1_1 : real;
	Interpolate2_Sum2_1_1 : real;
	Interpolate2_Sum3_1_1 : real;
	Interpolate2_Sum4_1_1 : real;
	Interpolate1_Interpolate_1_1 : real;
	Interpolate1_Sum1_1_1 : real;
	Interpolate1_Sum2_1_1 : real;
	Interpolate1_Sum3_1_1 : real;
	Interpolate1_Sum4_1_1 : real;
	Sum_1_1 : real;
let 
	CompInfEq2_1_1 = In_1_1 <= Idx2_1_1;
	CompInfEq3_1_1 = In_1_1 <= Idx3_1_1;
	CompInfEq4_1_1 = In_1_1 <= Idx4_1_1;
	CompSup1_1_1 = In_1_1 >= Idx1_1_1;
	CompSup2_1_1 = In_1_1 > Idx2_1_1;
	CompSup3_1_1 = In_1_1 > Idx3_1_1;
	Data1_1_1 = 1.00000000;
	Data2_1_1 = 1.00000000;
	Data3_1_1 = 0.30000000;
	Data4_1_1 = 0.30000000;
	Idx1_1_1 = 0.00000000;
	Idx2_1_1 = 120.00000000;
	Idx3_1_1 = 350.00000000;
	Idx4_1_1 = 500.00000000;
	Product1_1_1 = Interpolate1_Sum4_1_1 * (if CompSup1_1_1 then 1.0 else 0.0) * (if CompInfEq2_1_1 then 1.0 else 0.0);
	Product2_1_1 = Interpolate2_Sum4_1_1 * (if CompSup2_1_1 then 1.0 else 0.0) * (if CompInfEq3_1_1 then 1.0 else 0.0);
	Product3_1_1 = Interpolate3_Sum4_1_1 * (if CompSup3_1_1 then 1.0 else 0.0) * (if CompInfEq4_1_1 then 1.0 else 0.0);
	Interpolate3_Interpolate_1_1 = Interpolate3_Sum1_1_1 / Interpolate3_Sum2_1_1 * Interpolate3_Sum3_1_1;
	Interpolate3_Sum1_1_1 = In_1_1 - Idx3_1_1;
	Interpolate3_Sum2_1_1 =  - Idx3_1_1 + Idx4_1_1;
	Interpolate3_Sum3_1_1 =  - Data3_1_1 + Data4_1_1;
	Interpolate3_Sum4_1_1 = Interpolate3_Interpolate_1_1 + Data3_1_1;
	Interpolate2_Interpolate_1_1 = Interpolate2_Sum1_1_1 / Interpolate2_Sum2_1_1 * Interpolate2_Sum3_1_1;
	Interpolate2_Sum1_1_1 = In_1_1 - Idx2_1_1;
	Interpolate2_Sum2_1_1 =  - Idx2_1_1 + Idx3_1_1;
	Interpolate2_Sum3_1_1 =  - Data2_1_1 + Data3_1_1;
	Interpolate2_Sum4_1_1 = Interpolate2_Interpolate_1_1 + Data2_1_1;
	Interpolate1_Interpolate_1_1 = Interpolate1_Sum1_1_1 / Interpolate1_Sum2_1_1 * Interpolate1_Sum3_1_1;
	Interpolate1_Sum1_1_1 = In_1_1 - Idx1_1_1;
	Interpolate1_Sum2_1_1 =  - Idx1_1_1 + Idx2_1_1;
	Interpolate1_Sum3_1_1 =  - Data1_1_1 + Data2_1_1;
	Interpolate1_Sum4_1_1 = Interpolate1_Interpolate_1_1 + Data1_1_1;
	Sum_1_1 = Product1_1_1 + Product2_1_1 + Product3_1_1;
	Out_1_1 = Sum_1_1;
tel

node ControlsWithAutopilot_NoBus_PP_Discrete_Fcn_Atomic_Longitudinal_PitchInnerLoop (PitchCmd_1_1 : real; Pitch_1_1 : real; qdeg_1_1 : real; CAS_1_1 : real)
returns (ElevCmd_1_1 : real); 
var
	Kcas_pp_1_1 : real;
	Kpitch_1_1 : real;
	Kwo_1_1 : real;
	Mux_1_1 : real; Mux_1_2 : real;
	Product_1_1 : real;
	Sum_1_1 : real;
	Sum1_1_1 : real;
	TransferFcn_pp_1_1 : real;
let 
	Kcas_pp_1_1 = ControlsWithAutopilot_NoBus_PP_Discrete_Fcn_Atomic_Longitudinal_PitchInnerLoop_Kcas_pp(CAS_1_1);
	Kpitch_1_1 = 2.00000000 * Sum_1_1;
	Kwo_1_1 = 0.50000000 * TransferFcn_pp_1_1;
	Mux_1_1 = PitchCmd_1_1 ;
	Mux_1_2 = Pitch_1_1 ;
	Product_1_1 = Sum1_1_1 * Kcas_pp_1_1;
	Sum_1_1 = PitchCmd_1_1 - Pitch_1_1;
	Sum1_1_1 =  - Kpitch_1_1 + Kwo_1_1;
	TransferFcn_pp_1_1 = ControlsWithAutopilot_NoBus_PP_Discrete_Fcn_Atomic_Longitudinal_PitchInnerLoop_TransferFcn_pp(qdeg_1_1);
	ElevCmd_1_1 = Product_1_1;
tel

node ControlsWithAutopilot_NoBus_PP_Discrete_Fcn_Atomic_Longitudinal_FPAControl (engage_1_1 : bool; gamcmd_1_1 : real; gamma_1_1 : real; thetadeg_1_1 : real; VT_1_1 : real)
returns (PitchCmd_1_1 : real); 
var
	Integ_FPA_1_1 : real;
	KIgamerr_1_1 : real;
	Kgamerr_1_1 : real;
	LogicalOperator_1_1 : bool;
	Mux_1_1 : real; Mux_1_2 : real;
	Mux1_1_1 : real; Mux1_1_2 : real;
	Product1_1_1 : real;
	SaturationDynamic_1_1 : real;
	Sum_1_1 : real;
	Sum1_1_1 : real;
	Sum2_1_1 : real;
	hddLim_1_1 : real;
	kt2fps_1_1 : real;
	m1_1_1 : real;
	Integ_FPA_Reset_Trigger1_1: bool;
let 
	Integ_FPA_Reset_Trigger1_1 = false -> LogicalOperator_1_1 or (not(pre(LogicalOperator_1_1) = LogicalOperator_1_1));
	Integ_FPA_1_1 = Sum_1_1 -> if Integ_FPA_Reset_Trigger1_1 then Sum_1_1 else (1.00000000 * 1.00000000)*(pre SaturationDynamic_1_1) + pre Integ_FPA_1_1;
	KIgamerr_1_1 = 1.00000000 * Sum2_1_1;
	Kgamerr_1_1 = 1.40000000 * gamma_1_1;
	LogicalOperator_1_1 = not engage_1_1;
	Mux_1_1 = gamcmd_1_1 ;
	Mux_1_2 = gamma_1_1 ;
	Mux1_1_1 = Sum2_1_1 ;
	Mux1_1_2 = SaturationDynamic_1_1 ;
	Product1_1_1 = hddLim_1_1 * kt2fps_1_1;
	SaturationDynamic_1_1 = if KIgamerr_1_1 > Product1_1_1 then Product1_1_1
		else if KIgamerr_1_1 < m1_1_1 then m1_1_1
		else KIgamerr_1_1;
	Sum_1_1 = thetadeg_1_1 + Kgamerr_1_1;
	Sum1_1_1 = Integ_FPA_1_1 - Kgamerr_1_1;
	Sum2_1_1 = gamcmd_1_1 - gamma_1_1;
	hddLim_1_1 = 276.73871400;
	kt2fps_1_1 = 1.68780000 * VT_1_1;
	m1_1_1 = -1.00000000 * Product1_1_1;
	PitchCmd_1_1 = Sum1_1_1;
tel

node ControlsWithAutopilot_NoBus_PP_Discrete_Fcn_Atomic_Longitudinal_AltitudeControl_VariableLimitSaturation (up_lim_1_1 : real; SigIn_1_1 : real; Lo_lim_1_1 : real)
returns (Out1_1_1 : real); 
var
	Enforcelowlim_1_1 : real;
	Enforceuplim_1_1 : real;
let 
	Enforcelowlim_1_1 = if Lo_lim_1_1 >= SigIn_1_1 then Lo_lim_1_1 else SigIn_1_1;
	Enforceuplim_1_1 = if Enforcelowlim_1_1 <= up_lim_1_1 then Enforcelowlim_1_1 else up_lim_1_1;
	Out1_1_1 = Enforceuplim_1_1;
tel

node ControlsWithAutopilot_NoBus_PP_Discrete_Fcn_Atomic_Longitudinal_AltitudeControl_VariableRateLimit (ratelim_1_1 : real; input_1_1 : real; ICtrig_1_1 : bool; IC_1_1 : real)
returns (output_1_1 : real); 
var
	Gain_1_1 : real;
	Gain1_1_1 : real;
	Integrator_1_1 : real;
	Sum2_1_1 : real;
	VariableLimitSaturation_Enforcelowlim_1_1 : real;
	VariableLimitSaturation_Enforceuplim_1_1 : real;
	Integrator_Reset_Trigger1_1: bool;
let 
	Gain_1_1 = 20.00000000 * Sum2_1_1;
	Gain1_1_1 = -1.00000000 * ratelim_1_1;
	Integrator_Reset_Trigger1_1 = false -> ICtrig_1_1 or (not(pre(ICtrig_1_1) = ICtrig_1_1));
	Integrator_1_1 = IC_1_1 -> if Integrator_Reset_Trigger1_1 then IC_1_1 else (1.00000000 * 1.00000000)*(pre VariableLimitSaturation_Enforceuplim_1_1) + pre Integrator_1_1;
	Sum2_1_1 = input_1_1 - Integrator_1_1;
	VariableLimitSaturation_Enforcelowlim_1_1 = if Gain1_1_1 >= Gain_1_1 then Gain1_1_1 else Gain_1_1;
	VariableLimitSaturation_Enforceuplim_1_1 = if VariableLimitSaturation_Enforcelowlim_1_1 <= ratelim_1_1 then VariableLimitSaturation_Enforcelowlim_1_1 else ratelim_1_1;
	output_1_1 = Integrator_1_1;
tel

node ControlsWithAutopilot_NoBus_PP_Discrete_Fcn_Atomic_Longitudinal_AltitudeControl (engage_1_1 : bool; AltCmd_1_1 : real; Altitude_1_1 : real; gskts_1_1 : real; hdot_1_1 : real; hdotChgRate_1_1 : real; maxHdotChg_1_1 : real)
returns (altgamcmd_1_1 : real); 
var
	Abs_1_1 : real;
	Constant1_1_1 : real;
	Divide_1_1 : real;
	Kh_1_1 : real;
	LogicalOperator_1_1 : bool;
	Mux_1_1 : real; Mux_1_2 : real;
	Mux1_1_1 : real; Mux1_1_2 : real;
	Saturation_1_1 : real;
	Sum_1_1 : real;
	Sum3_1_1 : real;
	Switch_1_1 : real;
	VariableRateLimit_1_1 : real;
	VariableLimitSaturation_1_1 : real;
	k_1_1 : real;
	kts2fps_1_1 : real;
	r2d_1_1 : real;
let 
	Abs_1_1 = if hdot_1_1 >= 0.0 then hdot_1_1 else -hdot_1_1;
	Constant1_1_1 = 0.00000000;
	Divide_1_1 = VariableRateLimit_1_1 / Saturation_1_1;
	Kh_1_1 = 0.08000000 * Sum_1_1;
	LogicalOperator_1_1 = not engage_1_1;
	Mux_1_1 = AltCmd_1_1 ;
	Mux_1_2 = Altitude_1_1 ;
	Mux1_1_1 = VariableLimitSaturation_1_1 ;
	Mux1_1_2 = VariableRateLimit_1_1 ;
	Saturation_1_1 =  if kts2fps_1_1 >= 1000.000000 then 1000.000000 
		else if kts2fps_1_1 <= 0.000100 then 0.000100 
		else kts2fps_1_1 ;
	Sum_1_1 = AltCmd_1_1 - Altitude_1_1;
	Sum3_1_1 = Abs_1_1 + maxHdotChg_1_1;
	Switch_1_1 = if (if engage_1_1 then 1.0 else 0.0) >= 0.00000000 then Kh_1_1 else Constant1_1_1;
	VariableRateLimit_1_1 = ControlsWithAutopilot_NoBus_PP_Discrete_Fcn_Atomic_Longitudinal_AltitudeControl_VariableRateLimit(hdotChgRate_1_1, VariableLimitSaturation_1_1, LogicalOperator_1_1, hdot_1_1);
	VariableLimitSaturation_1_1 = ControlsWithAutopilot_NoBus_PP_Discrete_Fcn_Atomic_Longitudinal_AltitudeControl_VariableLimitSaturation(Sum3_1_1, Switch_1_1, k_1_1);
	k_1_1 = -1.00000000 * Sum3_1_1;
	kts2fps_1_1 = 1.68780000 * gskts_1_1;
	r2d_1_1 = 57.29580000 * Divide_1_1;
	altgamcmd_1_1 = r2d_1_1;
tel

node ControlsWithAutopilot_NoBus_PP_Discrete_Fcn_Atomic_Longitudinal (FPACmd_1_1 : real; AntEng_1_1 : bool; FpaEng_1_1 : bool; AltCmd_1_1 : real; Alt_1_1 : real; thetaDeg_1_1 : real; qDeg_1_1 : real; GsKts_1_1 : real; hdot_1_1 : real; VT_1_1 : real; Gamma_1_1 : real; CAS_1_1 : real; ElevStick_1_1 : real; ElevStick_1_2 : real; ElevStick_1_3 : real; hdotChgRate_1_1 : real; maxHdotChg_1_1 : real)
returns (ElevCmd_1_1 : real; ElevCmd_1_2 : real; ElevCmd_1_3 : real); 
var
	AltitudeControl_1_1 : real;
	FPAControl_1_1 : real;
	LogicalOperator_1_1 : bool;
	PitchInnerLoop_1_1 : real;
	Sum7_1_1 : real;
	k2_1_1 : real;
	ManualOverride_Switch1_1_1 : real; ManualOverride_Switch1_1_2 : real; ManualOverride_Switch1_1_3 : real;
	EngageORzero_LogicalOperator5_1_1 : bool;
	EngageORzero_Switch1_1_1 : real;
	EngageORzero_zero10_1_1 : real;
	EngageORzero_zero9_1_1 : real;
	k5_1_1 : real;
let 
	AltitudeControl_1_1 = ControlsWithAutopilot_NoBus_PP_Discrete_Fcn_Atomic_Longitudinal_AltitudeControl(AntEng_1_1, AltCmd_1_1, Alt_1_1, GsKts_1_1, hdot_1_1, hdotChgRate_1_1, maxHdotChg_1_1);
	FPAControl_1_1 = ControlsWithAutopilot_NoBus_PP_Discrete_Fcn_Atomic_Longitudinal_FPAControl(FpaEng_1_1, Sum7_1_1, Gamma_1_1, thetaDeg_1_1, VT_1_1);
	LogicalOperator_1_1 = AntEng_1_1 or FpaEng_1_1;
	PitchInnerLoop_1_1 = ControlsWithAutopilot_NoBus_PP_Discrete_Fcn_Atomic_Longitudinal_PitchInnerLoop(k5_1_1, thetaDeg_1_1, qDeg_1_1, CAS_1_1);
	Sum7_1_1 = FPACmd_1_1 + k2_1_1;
	k2_1_1 = 1.00000000 * AltitudeControl_1_1;
	ManualOverride_Switch1_1_1 = if not(ElevStick_1_3 = 0.0) then EngageORzero_Switch1_1_1 else ElevStick_1_3;
	ManualOverride_Switch1_1_2 = if not(ElevStick_1_3 = 0.0) then EngageORzero_Switch1_1_1 else ElevStick_1_3;
	ManualOverride_Switch1_1_3 = if not(ElevStick_1_3 = 0.0) then EngageORzero_Switch1_1_1 else ElevStick_1_3;
	EngageORzero_LogicalOperator5_1_1 = LogicalOperator_1_1 and (EngageORzero_zero10_1_1 != 0.0);
	EngageORzero_Switch1_1_1 = if (if EngageORzero_LogicalOperator5_1_1 then 1.0 else 0.0) >= 0.50000000 then PitchInnerLoop_1_1 else EngageORzero_zero9_1_1;
	EngageORzero_zero10_1_1 = 1.00000000;
	EngageORzero_zero9_1_1 = 0.00000000;
	k5_1_1 = 1.00000000 * FPAControl_1_1;
	ElevCmd_1_1 = ManualOverride_Switch1_1_1;
	ElevCmd_1_2 = ManualOverride_Switch1_1_2;
	ElevCmd_1_3 = ManualOverride_Switch1_1_3;
tel

node ControlsWithAutopilot_NoBus_PP_Discrete_Fcn_Atomic_Heading_RollInnerLoop_Kcas_pp (In_1_1 : real)
returns (Out_1_1 : real); 
var
	CompInfEq2_1_1 : bool;
	CompInfEq3_1_1 : bool;
	CompInfEq4_1_1 : bool;
	CompSup1_1_1 : bool;
	CompSup2_1_1 : bool;
	CompSup3_1_1 : bool;
	Data1_1_1 : real;
	Data2_1_1 : real;
	Data3_1_1 : real;
	Data4_1_1 : real;
	Idx1_1_1 : real;
	Idx2_1_1 : real;
	Idx3_1_1 : real;
	Idx4_1_1 : real;
	Product1_1_1 : real;
	Product2_1_1 : real;
	Product3_1_1 : real;
	Interpolate3_Interpolate_1_1 : real;
	Interpolate3_Sum1_1_1 : real;
	Interpolate3_Sum2_1_1 : real;
	Interpolate3_Sum3_1_1 : real;
	Interpolate3_Sum4_1_1 : real;
	Interpolate2_Interpolate_1_1 : real;
	Interpolate2_Sum1_1_1 : real;
	Interpolate2_Sum2_1_1 : real;
	Interpolate2_Sum3_1_1 : real;
	Interpolate2_Sum4_1_1 : real;
	Interpolate1_Interpolate_1_1 : real;
	Interpolate1_Sum1_1_1 : real;
	Interpolate1_Sum2_1_1 : real;
	Interpolate1_Sum3_1_1 : real;
	Interpolate1_Sum4_1_1 : real;
	Sum_1_1 : real;
let 
	CompInfEq2_1_1 = In_1_1 <= Idx2_1_1;
	CompInfEq3_1_1 = In_1_1 <= Idx3_1_1;
	CompInfEq4_1_1 = In_1_1 <= Idx4_1_1;
	CompSup1_1_1 = In_1_1 >= Idx1_1_1;
	CompSup2_1_1 = In_1_1 > Idx2_1_1;
	CompSup3_1_1 = In_1_1 > Idx3_1_1;
	Data1_1_1 = 1.00000000;
	Data2_1_1 = 1.00000000;
	Data3_1_1 = 0.30000000;
	Data4_1_1 = 0.30000000;
	Idx1_1_1 = 0.00000000;
	Idx2_1_1 = 120.00000000;
	Idx3_1_1 = 350.00000000;
	Idx4_1_1 = 500.00000000;
	Product1_1_1 = Interpolate1_Sum4_1_1 * (if CompSup1_1_1 then 1.0 else 0.0) * (if CompInfEq2_1_1 then 1.0 else 0.0);
	Product2_1_1 = Interpolate2_Sum4_1_1 * (if CompSup2_1_1 then 1.0 else 0.0) * (if CompInfEq3_1_1 then 1.0 else 0.0);
	Product3_1_1 = Interpolate3_Sum4_1_1 * (if CompSup3_1_1 then 1.0 else 0.0) * (if CompInfEq4_1_1 then 1.0 else 0.0);
	Interpolate3_Interpolate_1_1 = Interpolate3_Sum1_1_1 / Interpolate3_Sum2_1_1 * Interpolate3_Sum3_1_1;
	Interpolate3_Sum1_1_1 = In_1_1 - Idx3_1_1;
	Interpolate3_Sum2_1_1 =  - Idx3_1_1 + Idx4_1_1;
	Interpolate3_Sum3_1_1 =  - Data3_1_1 + Data4_1_1;
	Interpolate3_Sum4_1_1 = Interpolate3_Interpolate_1_1 + Data3_1_1;
	Interpolate2_Interpolate_1_1 = Interpolate2_Sum1_1_1 / Interpolate2_Sum2_1_1 * Interpolate2_Sum3_1_1;
	Interpolate2_Sum1_1_1 = In_1_1 - Idx2_1_1;
	Interpolate2_Sum2_1_1 =  - Idx2_1_1 + Idx3_1_1;
	Interpolate2_Sum3_1_1 =  - Data2_1_1 + Data3_1_1;
	Interpolate2_Sum4_1_1 = Interpolate2_Interpolate_1_1 + Data2_1_1;
	Interpolate1_Interpolate_1_1 = Interpolate1_Sum1_1_1 / Interpolate1_Sum2_1_1 * Interpolate1_Sum3_1_1;
	Interpolate1_Sum1_1_1 = In_1_1 - Idx1_1_1;
	Interpolate1_Sum2_1_1 =  - Idx1_1_1 + Idx2_1_1;
	Interpolate1_Sum3_1_1 =  - Data1_1_1 + Data2_1_1;
	Interpolate1_Sum4_1_1 = Interpolate1_Interpolate_1_1 + Data1_1_1;
	Sum_1_1 = Product1_1_1 + Product2_1_1 + Product3_1_1;
	Out_1_1 = Sum_1_1;
tel

node ControlsWithAutopilot_NoBus_PP_Discrete_Fcn_Atomic_Heading_RollInnerLoop (RollCmd_1_1 : real; Roll_1_1 : real; pdeg_1_1 : real; CAS_1_1 : real)
returns (AilCmd_1_1 : real); 
var
	Kcas_pp_1_1 : real;
	Kphierr_1_1 : real;
	Product_1_1 : real;
	Sum_1_1 : real;
	Sum1_1_1 : real;
	rollrate_IL_1_1 : real;
let 
	Kcas_pp_1_1 = ControlsWithAutopilot_NoBus_PP_Discrete_Fcn_Atomic_Heading_RollInnerLoop_Kcas_pp(CAS_1_1);
	Kphierr_1_1 = 0.50000000 * Sum_1_1;
	Product_1_1 = Sum1_1_1 * Kcas_pp_1_1;
	Sum_1_1 = RollCmd_1_1 - Roll_1_1;
	Sum1_1_1 = Kphierr_1_1 - rollrate_IL_1_1;
	rollrate_IL_1_1 = 0.00645000 * ((pdeg_1_1 - 0.00000000) / (pdeg_1_1 - -0.50000000));
	AilCmd_1_1 = Product_1_1;
tel

node ControlsWithAutopilot_NoBus_PP_Discrete_Fcn_Atomic_Heading_HeadingControl_HdgCmdProcessor_VarLimIntegIC (UpLim_1_1 : real; LoLim_1_1 : real; In_1_1 : real; Trig_1_1 : bool; IC_1_1 : real)
returns (Out_1_1 : real); 
var
	Constant1_1_1 : real;
	Constant2_1_1 : real;
	Constant3_1_1 : real;
	LogicalOperator_1_1 : bool;
	LogicalOperator1_1_1 : bool;
	LogicalOperator2_1_1 : bool;
	RelationalOperator_1_1 : bool;
	RelationalOperator1_1_1 : bool;
	RelationalOperator2_1_1 : bool;
	RelationalOperator3_1_1 : bool;
	Switch1_1_1 : real;
	Switch2_1_1 : real;
	Switch3_1_1 : real;
	VarLimitIntegrator_1_1 : real;
	VarLimitIntegrator_Reset_Trigger1_1: bool;
let 
	Constant1_1_1 = 0.00000000;
	Constant2_1_1 = 0.00000000;
	Constant3_1_1 = 0.00000000;
	LogicalOperator_1_1 = RelationalOperator_1_1 and RelationalOperator2_1_1;
	LogicalOperator1_1_1 = RelationalOperator3_1_1 and RelationalOperator1_1_1;
	LogicalOperator2_1_1 = LogicalOperator_1_1 or LogicalOperator1_1_1;
	RelationalOperator_1_1 = UpLim_1_1 <= VarLimitIntegrator_1_1;
	RelationalOperator1_1_1 = LoLim_1_1 >= Switch1_1_1;
	RelationalOperator2_1_1 = In_1_1 > Constant1_1_1;
	RelationalOperator3_1_1 = In_1_1 < Constant2_1_1;
	Switch1_1_1 = if (if RelationalOperator_1_1 then 1.0 else 0.0) >= 0.50000000 then UpLim_1_1 else VarLimitIntegrator_1_1;
	Switch2_1_1 = if (if RelationalOperator1_1_1 then 1.0 else 0.0) >= 0.50000000 then LoLim_1_1 else Switch1_1_1;
	Switch3_1_1 = if (if LogicalOperator2_1_1 then 1.0 else 0.0) >= 0.50000000 then Constant3_1_1 else In_1_1;
	VarLimitIntegrator_Reset_Trigger1_1 = false -> Trig_1_1 or (not(pre(Trig_1_1) = Trig_1_1));
	VarLimitIntegrator_1_1 = IC_1_1 -> if VarLimitIntegrator_Reset_Trigger1_1 then IC_1_1 else (1.00000000 * 1.00000000)*(pre Switch3_1_1) + pre VarLimitIntegrator_1_1;
	Out_1_1 = Switch2_1_1;
tel

node ControlsWithAutopilot_NoBus_PP_Discrete_Fcn_Atomic_Heading_HeadingControl (HdgCmdMCP_1_1 : real; Heading_1_1 : real; psidot_1_1 : real; Vt_1_1 : real; Roll_1_1 : real; HeadEng_1_1 : bool; RollLimit_1_1 : real)
returns (RollCmd_1_1 : real); 
var
	Khdg_1_1 : real;
	Khdg1_1_1 : real;
	Khdg2_1_1 : real;
	Khdgrte_1_1 : real;
	LogicalOperator_1_1 : bool;
	MinMax_1_1 : real;
	MinMax1_1_1 : real;
	Mux_1_1 : real; Mux_1_2 : real;
	Sum_1_1 : real;
	Sum1_1_1 : real;
	Sum2_1_1 : real;
	Sum3_1_1 : real;
	Sum4_1_1 : real;
	VarLimIntegIC_Constant1_1_1 : real;
	VarLimIntegIC_Constant2_1_1 : real;
	VarLimIntegIC_Constant3_1_1 : real;
	VarLimIntegIC_Integrator_1_1 : real;
	VarLimIntegIC_LogicalOperator_1_1 : bool;
	VarLimIntegIC_LogicalOperator1_1_1 : bool;
	VarLimIntegIC_LogicalOperator2_1_1 : bool;
	VarLimIntegIC_RelationalOperator_1_1 : bool;
	VarLimIntegIC_RelationalOperator1_1_1 : bool;
	VarLimIntegIC_RelationalOperator2_1_1 : bool;
	VarLimIntegIC_RelationalOperator3_1_1 : bool;
	VarLimIntegIC_Switch1_1_1 : real;
	VarLimIntegIC_Switch2_1_1 : real;
	VarLimIntegIC_Switch3_1_1 : real;
	HdgCmdProcessor__2zetaOmega_1_1 : real;
	HdgCmdProcessor_Constant_1_1 : real;
	HdgCmdProcessor_Constant1_1_1 : real;
	HdgCmdProcessor_Constant2_1_1 : real;
	HdgCmdProcessor_HeadingIntegrator_1_1 : real;
	HdgCmdProcessor_LogicalOperator_1_1 : bool;
	HdgCmdProcessor_Product1_1_1 : real;
	HdgCmdProcessor_Product2_1_1 : real;
	HdgCmdProcessor_Product3_1_1 : real;
	HdgCmdProcessor_Saturation_1_1 : real;
	HdgCmdProcessor_SaturationDynamic1_1_1 : real;
	HdgCmdProcessor_Sum_1_1 : real;
	HdgCmdProcessor_Sum2_1_1 : real;
	HdgCmdProcessor_Sum3_1_1 : real;
	HdgCmdProcessor_TrigonometricFunction_1_1 : real;
	HdgCmdProcessor_VarLimIntegIC_1_1 : real;
	HdgCmdProcessor_init_1_1 : real;
	HdgCmdProcessor_k_1_1 : real;
	HdgCmdProcessor_k1_1_1 : real;
	HdgCmdProcessor_k2_1_1 : real;
	HdgCmdProcessor_k3_1_1 : real;
	HdgCmdProcessor_k4_1_1 : real;
	HdgCmdProcessor_k5_1_1 : real;
	HdgCmdProcessor_k6_1_1 : real;
	HdgCmdProcessor_omegaSq_1_1 : real;
	HdgCmdProcessor_ANGL_Abs_1_1 : real;
	HdgCmdProcessor_ANGL_Constant_1_1 : real;
	HdgCmdProcessor_ANGL_Constant1_1_1 : real;
	HdgCmdProcessor_ANGL_Product_1_1 : real;
	HdgCmdProcessor_ANGL_RelationalOperator_1_1 : bool;
	HdgCmdProcessor_ANGL_RelationalOperator1_1_1 : bool;
	HdgCmdProcessor_ANGL_Sum6_1_1 : real;
	HdgCmdProcessor_ANGL_Switch1_1_1 : real;
	HdgCmdProcessor_ANGL_zero_1_1 : real;
	HdgCmdProcessor_omegaSq2_1_1 : real;
	sgn_1_1 : real;
	Integrator_Reset_Trigger1_1: bool;
	HeadingIntegrator_Reset_Trigger1_1: bool;
let 
	Khdg_1_1 = 0.05000000 * Sum_1_1;
	Khdg1_1_1 = 1.00000000 * Sum3_1_1;
	Khdg2_1_1 = 1.00000000 * Sum4_1_1;
	Khdgrte_1_1 = 3.00000000 * Sum1_1_1;
	LogicalOperator_1_1 = not HeadEng_1_1;
	MinMax_1_1 = if MinMax1_1_1 <= Khdg2_1_1 then MinMax1_1_1 else Khdg2_1_1;
	MinMax1_1_1 = if Khdgrte_1_1 >= Khdg1_1_1 then Khdgrte_1_1 else Khdg1_1_1;
	Mux_1_1 = HdgCmdMCP_1_1 ;
	Mux_1_2 = HdgCmdProcessor_HeadingIntegrator_1_1 ;
	Sum_1_1 = HdgCmdProcessor_HeadingIntegrator_1_1 - Heading_1_1;
	Sum1_1_1 = Khdg_1_1 + Sum2_1_1;
	Sum2_1_1 = HdgCmdProcessor_VarLimIntegIC_1_1 - psidot_1_1;
	Sum3_1_1 =  - VarLimIntegIC_Switch2_1_1 - RollLimit_1_1;
	Sum4_1_1 = RollLimit_1_1 - VarLimIntegIC_Switch2_1_1;
	VarLimIntegIC_Constant1_1_1 = 0.00000000;
	VarLimIntegIC_Constant2_1_1 = 0.00000000;
	VarLimIntegIC_Constant3_1_1 = 0.00000000;
	Integrator_Reset_Trigger1_1 = false -> LogicalOperator_1_1 or (not(pre(LogicalOperator_1_1) = LogicalOperator_1_1));
	VarLimIntegIC_Integrator_1_1 = Roll_1_1 -> if Integrator_Reset_Trigger1_1 then Roll_1_1 else (1.00000000 * 1.00000000)*(pre VarLimIntegIC_Switch3_1_1) + pre VarLimIntegIC_Integrator_1_1;
	VarLimIntegIC_LogicalOperator_1_1 = VarLimIntegIC_RelationalOperator_1_1 and VarLimIntegIC_RelationalOperator2_1_1;
	VarLimIntegIC_LogicalOperator1_1_1 = VarLimIntegIC_RelationalOperator3_1_1 and VarLimIntegIC_RelationalOperator1_1_1;
	VarLimIntegIC_LogicalOperator2_1_1 = VarLimIntegIC_LogicalOperator_1_1 or VarLimIntegIC_LogicalOperator1_1_1;
	VarLimIntegIC_RelationalOperator_1_1 = RollLimit_1_1 <= VarLimIntegIC_Integrator_1_1;
	VarLimIntegIC_RelationalOperator1_1_1 = sgn_1_1 >= VarLimIntegIC_Switch1_1_1;
	VarLimIntegIC_RelationalOperator2_1_1 = MinMax_1_1 > VarLimIntegIC_Constant1_1_1;
	VarLimIntegIC_RelationalOperator3_1_1 = MinMax_1_1 < VarLimIntegIC_Constant2_1_1;
	VarLimIntegIC_Switch1_1_1 = if (if VarLimIntegIC_RelationalOperator_1_1 then 1.0 else 0.0) >= 0.50000000 then RollLimit_1_1 else VarLimIntegIC_Integrator_1_1;
	VarLimIntegIC_Switch2_1_1 = if (if VarLimIntegIC_RelationalOperator1_1_1 then 1.0 else 0.0) >= 0.50000000 then sgn_1_1 else VarLimIntegIC_Switch1_1_1;
	VarLimIntegIC_Switch3_1_1 = if (if VarLimIntegIC_LogicalOperator2_1_1 then 1.0 else 0.0) >= 0.50000000 then VarLimIntegIC_Constant3_1_1 else MinMax_1_1;
	HdgCmdProcessor__2zetaOmega_1_1 = HdgCmdProcessor_VarLimIntegIC_1_1 * HdgCmdProcessor_k6_1_1;
	HdgCmdProcessor_Constant_1_1 = 1.60000000;
	HdgCmdProcessor_Constant1_1_1 = 0.00000000;
	HdgCmdProcessor_Constant2_1_1 = 514.80000000;
	HeadingIntegrator_Reset_Trigger1_1 = false -> HdgCmdProcessor_LogicalOperator_1_1 or (not(pre(HdgCmdProcessor_LogicalOperator_1_1) = HdgCmdProcessor_LogicalOperator_1_1));
	HdgCmdProcessor_HeadingIntegrator_1_1 = Heading_1_1 -> if HeadingIntegrator_Reset_Trigger1_1 then Heading_1_1 else (1.00000000 * 1.00000000)*(pre HdgCmdProcessor_VarLimIntegIC_1_1) + pre HdgCmdProcessor_HeadingIntegrator_1_1;
	HdgCmdProcessor_LogicalOperator_1_1 = not (HdgCmdMCP_1_1 != 0.0);
	HdgCmdProcessor_Product1_1_1 = HdgCmdProcessor_Constant1_1_1 * HdgCmdProcessor_Saturation_1_1;
	HdgCmdProcessor_Product2_1_1 = HdgCmdProcessor_Constant2_1_1 / HdgCmdProcessor_Saturation_1_1;
	HdgCmdProcessor_Product3_1_1 = (1.0 / HdgCmdProcessor_k5_1_1) * HdgCmdProcessor_Saturation_1_1;
	HdgCmdProcessor_Saturation_1_1 =  if HdgCmdProcessor_k2_1_1 >= 1000.000000 then 1000.000000 
		else if HdgCmdProcessor_k2_1_1 <= 0.000100 then 0.000100 
		else HdgCmdProcessor_k2_1_1 ;
	HdgCmdProcessor_SaturationDynamic1_1_1 = if HdgCmdProcessor_Sum3_1_1 > HdgCmdProcessor_Product2_1_1 then HdgCmdProcessor_Product2_1_1
		else if HdgCmdProcessor_Sum3_1_1 < HdgCmdProcessor_k_1_1 then HdgCmdProcessor_k_1_1
		else HdgCmdProcessor_Sum3_1_1;
	HdgCmdProcessor_Sum_1_1 = HdgCmdProcessor_Constant_1_1 - HdgCmdProcessor_Product1_1_1;
	HdgCmdProcessor_Sum2_1_1 = HdgCmdMCP_1_1 - HdgCmdProcessor_HeadingIntegrator_1_1;
	HdgCmdProcessor_Sum3_1_1 = HdgCmdProcessor_omegaSq2_1_1 - HdgCmdProcessor__2zetaOmega_1_1;
	HdgCmdProcessor_TrigonometricFunction_1_1 = tan(HdgCmdProcessor_k3_1_1);
	HdgCmdProcessor_VarLimIntegIC_1_1 = ControlsWithAutopilot_NoBus_PP_Discrete_Fcn_Atomic_Heading_HeadingControl_HdgCmdProcessor_VarLimIntegIC(HdgCmdProcessor_Product3_1_1, HdgCmdProcessor_k1_1_1, HdgCmdProcessor_SaturationDynamic1_1_1, HdgCmdProcessor_LogicalOperator_1_1, HdgCmdProcessor_init_1_1);
	HdgCmdProcessor_init_1_1 = 0.00000000;
	HdgCmdProcessor_k_1_1 = -1.00000000 * HdgCmdProcessor_Product2_1_1;
	HdgCmdProcessor_k1_1_1 = -1.00000000 * HdgCmdProcessor_Product3_1_1;
	HdgCmdProcessor_k2_1_1 = 1.68780000 * Vt_1_1;
	HdgCmdProcessor_k3_1_1 = 0.01745329 * RollLimit_1_1;
	HdgCmdProcessor_k4_1_1 = 32.17400000 * HdgCmdProcessor_TrigonometricFunction_1_1;
	HdgCmdProcessor_k5_1_1 = 57.29577951 * HdgCmdProcessor_k4_1_1;
	HdgCmdProcessor_k6_1_1 = 2.00000000 * HdgCmdProcessor_Sum_1_1;
	HdgCmdProcessor_omegaSq_1_1 = HdgCmdProcessor_Sum_1_1 * HdgCmdProcessor_Sum_1_1;
	HdgCmdProcessor_ANGL_Abs_1_1 = if HdgCmdProcessor_Sum2_1_1 >= 0.0 then HdgCmdProcessor_Sum2_1_1 else -HdgCmdProcessor_Sum2_1_1;
	HdgCmdProcessor_ANGL_Constant_1_1 = 360.00000000;
	HdgCmdProcessor_ANGL_Constant1_1_1 = 180.00000000;
	HdgCmdProcessor_ANGL_Product_1_1 = HdgCmdProcessor_ANGL_Constant_1_1 * (if HdgCmdProcessor_ANGL_RelationalOperator1_1_1 then 1.0 else 0.0);
	HdgCmdProcessor_ANGL_RelationalOperator_1_1 = HdgCmdProcessor_ANGL_Abs_1_1 > HdgCmdProcessor_ANGL_Constant1_1_1;
	HdgCmdProcessor_ANGL_RelationalOperator1_1_1 = HdgCmdProcessor_ANGL_zero_1_1 < HdgCmdProcessor_Sum2_1_1;
	HdgCmdProcessor_ANGL_Sum6_1_1 =  - HdgCmdProcessor_ANGL_Product_1_1 + HdgCmdProcessor_Sum2_1_1;
	HdgCmdProcessor_ANGL_Switch1_1_1 = if (if HdgCmdProcessor_ANGL_RelationalOperator_1_1 then 1.0 else 0.0) >= 0.10000000 then HdgCmdProcessor_ANGL_Sum6_1_1 else HdgCmdProcessor_Sum2_1_1;
	HdgCmdProcessor_ANGL_zero_1_1 = 0.00000000;
	HdgCmdProcessor_omegaSq2_1_1 = HdgCmdProcessor_omegaSq_1_1 * HdgCmdProcessor_ANGL_Switch1_1_1;
	sgn_1_1 = -1.00000000 * RollLimit_1_1;
	RollCmd_1_1 = VarLimIntegIC_Switch2_1_1;
tel

node ControlsWithAutopilot_NoBus_PP_Discrete_Fcn_Atomic_Heading (HeadEng_1_1 : bool; HeadCmd_1_1 : real; Roll_1_1 : real; Heading_1_1 : real; CAS_1_1 : real; psidot_1_1 : real; Vt_1_1 : real; pDeg_1_1 : real; RollLimit_1_1 : real; AilStick_1_1 : real; AilStick_1_2 : real)
returns (AilCmd_1_1 : real; AilCmd_1_2 : real); 
var
	Gain1_1_1 : real; Gain1_1_2 : real;
	HeadingControl_1_1 : real;
	ManualOverride_Switch1_1_1 : real; ManualOverride_Switch1_1_2 : real;
	EngageORzero_LogicalOperator5_1_1 : bool;
	EngageORzero_Switch1_1_1 : real;
	EngageORzero_zero10_1_1 : real;
	EngageORzero_zero9_1_1 : real;
	RollInnerLoop_1_1 : real;
let 
	Gain1_1_1 = -1.00000000 * ManualOverride_Switch1_1_1;
	Gain1_1_2 = -1.00000000 * ManualOverride_Switch1_1_2;
	HeadingControl_1_1 = ControlsWithAutopilot_NoBus_PP_Discrete_Fcn_Atomic_Heading_HeadingControl(HeadCmd_1_1, Heading_1_1, psidot_1_1, Vt_1_1, Roll_1_1, HeadEng_1_1, RollLimit_1_1);
	ManualOverride_Switch1_1_1 = if not(AilStick_1_2 = 0.0) then EngageORzero_Switch1_1_1 else AilStick_1_2;
	ManualOverride_Switch1_1_2 = if not(AilStick_1_2 = 0.0) then EngageORzero_Switch1_1_1 else AilStick_1_2;
	EngageORzero_LogicalOperator5_1_1 = HeadEng_1_1 and (EngageORzero_zero10_1_1 != 0.0);
	EngageORzero_Switch1_1_1 = if (if EngageORzero_LogicalOperator5_1_1 then 1.0 else 0.0) >= 0.50000000 then RollInnerLoop_1_1 else EngageORzero_zero9_1_1;
	EngageORzero_zero10_1_1 = 1.00000000;
	EngageORzero_zero9_1_1 = 0.00000000;
	RollInnerLoop_1_1 = ControlsWithAutopilot_NoBus_PP_Discrete_Fcn_Atomic_Heading_RollInnerLoop(HeadingControl_1_1, Roll_1_1, pDeg_1_1, CAS_1_1);
	AilCmd_1_1 = Gain1_1_1;
	AilCmd_1_2 = Gain1_1_2;
tel

node ControlsWithAutopilot_NoBus_PP_Discrete_Fcn_Atomic_AutoThrottle_VarLimIntegAT (Input_1_1 : real; Max_1_1 : real; Min_1_1 : real; ICtrig_1_1 : bool; IC_1_1 : real)
returns (Out_1_1 : real); 
var
	Constant1_1_1 : real;
	Constant2_1_1 : real;
	Constant3_1_1 : real;
	Integrator1_1_1 : real;
	LogicalOperator1_1_1 : bool;
	LogicalOperator2_1_1 : bool;
	LogicalOperator3_1_1 : bool;
	RelationalOperator1_1_1 : bool;
	RelationalOperator2_1_1 : bool;
	RelationalOperator3_1_1 : bool;
	RelationalOperator4_1_1 : bool;
	Switch1_1_1 : real;
	Integrator1_Reset_Trigger1_1: bool;
let 
	Constant1_1_1 = 0.00000000;
	Constant2_1_1 = 0.00000000;
	Constant3_1_1 = 0.00000000;
	Integrator1_Reset_Trigger1_1 = false -> ICtrig_1_1 or (not(pre(ICtrig_1_1) = ICtrig_1_1));
	Integrator1_1_1 = IC_1_1 -> if Integrator1_Reset_Trigger1_1 then IC_1_1 else (1.00000000 * 1.00000000)*(pre Switch1_1_1) + pre Integrator1_1_1;
	LogicalOperator1_1_1 = LogicalOperator2_1_1 or LogicalOperator3_1_1;
	LogicalOperator2_1_1 = RelationalOperator2_1_1 and RelationalOperator3_1_1;
	LogicalOperator3_1_1 = RelationalOperator1_1_1 and RelationalOperator4_1_1;
	RelationalOperator1_1_1 = Integrator1_1_1 <= Min_1_1;
	RelationalOperator2_1_1 = Integrator1_1_1 >= Max_1_1;
	RelationalOperator3_1_1 = Input_1_1 > Constant2_1_1;
	RelationalOperator4_1_1 = Input_1_1 < Constant3_1_1;
	Switch1_1_1 = if (if LogicalOperator1_1_1 then 1.0 else 0.0) >= 0.10000000 then Constant1_1_1 else Input_1_1;
	Out_1_1 = Integrator1_1_1;
tel

node ControlsWithAutopilot_NoBus_PP_Discrete_Fcn_Atomic_AutoThrottle_TransferFcn_pp (Inport1_1_1 : real)
returns (Outport1_1_1 : real); 
var
	D1_1_1 : real;
	GainAC1_1_1_1 : real;
	GainAC2_1_1_1 : real;
	GainBD1_1_1_1 : real;
	GainBD2_1_1_1 : real;
	Sum1_1_1 : real;
	Sum2_1_1 : real;
let 
	D1_1_1 = 0.00000000 -> pre Sum1_1_1;
	GainAC1_1_1_1 = -0.06250000 * D1_1_1;
	GainAC2_1_1_1 = -0.06250000 * D1_1_1;
	GainBD1_1_1_1 = 1.00000000 * Inport1_1_1;
	GainBD2_1_1_1 = 1.00000000 * Inport1_1_1;
	Sum1_1_1 = GainAC1_1_1_1 + GainBD1_1_1_1;
	Sum2_1_1 = GainAC2_1_1_1 + GainBD2_1_1_1;
	Outport1_1_1 = Sum2_1_1;
tel

node ControlsWithAutopilot_NoBus_PP_Discrete_Fcn_Atomic_AutoThrottle (ATEng_1_1 : bool; CAScmd_1_1 : real; MachCmd_1_1 : real; MachSel_1_1 : real; Sensors_1_1 : real; Sensors_1_2 : real; Sensors_1_3 : real; Sensors_1_4 : real; Sensors_1_5 : real; maxThrot_1_1 : real; minThrot_1_1 : real; leverThrot_1_1 : real; leverThrot_1_2 : real)
returns (ThrotCmd_1_1 : real; ThrotCmd_1_2 : real); 
var
	Demux1_1_1 : real; Demux1_2_1 : real; Demux1_3_1 : real; Demux1_4_1 : real; Demux1_5_1 : real;
	Gain_1_1 : real;
	Gain1_1_1 : real;
	ICthrot_1_1 : real;
	ICthrot1_1_1 : real;
	Kcas_1_1 : real;
	Kr_1_1 : real;
	Kr1_1_1 : real;
	Ktas_1_1 : real;
	LogicalOperator_1_1 : bool;
	PHIMC1_1_1 : real;
	Product_1_1 : real;
	Product1_1_1 : real;
	RollComp1_1_1 : real;
	SaturationDynamic1_1_1 : real;
	Sum_1_1 : real;
	Sum1_1_1 : real;
	Sum2_1_1 : real;
	Sum3_1_1 : real;
	Sum4_1_1 : real;
	Sum5_1_1 : real;
	TransferFcn_pp_1_1 : real;
	TrigonometricFunction_1_1 : real;
	VarLimIntegAT_1_1 : real;
	kt2fps_1_1 : real;
	kt2fps1_1_1 : real;
	ManualOverride_Switch1_1_1 : real; ManualOverride_Switch1_1_2 : real;
	EngageORzero_LogicalOperator5_1_1 : bool;
	EngageORzero_Switch1_1_1 : real;
	EngageORzero_zero10_1_1 : real;
	EngageORzero_zero9_1_1 : real;
	one_1_1 : real;
let 
	Demux1_1_1 = Sensors_1_1 ;
	Demux1_2_1 = Sensors_1_2 ;
	Demux1_3_1 = Sensors_1_3 ;
	Demux1_4_1 = Sensors_1_4 ;
	Demux1_5_1 = Sensors_1_5 ;
	Gain_1_1 = 0.01745329 * Demux1_1_1;
	Gain1_1_1 = 5.00000000 * Sum_1_1;
	ICthrot_1_1 = 1.00000000;
	ICthrot1_1_1 = 1.00000000;
	Kcas_1_1 = 0.20000000 * kt2fps_1_1;
	Kr_1_1 = 2.50000000 * Sum1_1_1;
	Kr1_1_1 = 1.20000000 * Demux1_5_1;
	Ktas_1_1 = 0.11000000 * Product_1_1;
	LogicalOperator_1_1 = not ATEng_1_1;
	PHIMC1_1_1 = if MachSel_1_1 >= 0.50000000 then Ktas_1_1 else Kcas_1_1;
	Product_1_1 = kt2fps1_1_1 * Sum4_1_1;
	Product1_1_1 = MachCmd_1_1 / Demux1_3_1;
	RollComp1_1_1 = 1.00000000;
	SaturationDynamic1_1_1 = if Sum3_1_1 > maxThrot_1_1 then maxThrot_1_1
		else if Sum3_1_1 < minThrot_1_1 then minThrot_1_1
		else Sum3_1_1;
	Sum_1_1 = RollComp1_1_1 - TrigonometricFunction_1_1;
	Sum1_1_1 = TransferFcn_pp_1_1 + PHIMC1_1_1 - Demux1_5_1;
	Sum2_1_1 = CAScmd_1_1 - Demux1_4_1;
	Sum3_1_1 = VarLimIntegAT_1_1 - Kr1_1_1;
	Sum4_1_1 = Product1_1_1 - one_1_1;
	Sum5_1_1 = SaturationDynamic1_1_1 - ICthrot1_1_1;
	TransferFcn_pp_1_1 = ControlsWithAutopilot_NoBus_PP_Discrete_Fcn_Atomic_AutoThrottle_TransferFcn_pp(Gain1_1_1);
	TrigonometricFunction_1_1 = cos(Gain_1_1);
	VarLimIntegAT_1_1 = ControlsWithAutopilot_NoBus_PP_Discrete_Fcn_Atomic_AutoThrottle_VarLimIntegAT(Kr_1_1, maxThrot_1_1, minThrot_1_1, LogicalOperator_1_1, ICthrot_1_1);
	kt2fps_1_1 = 1.68780000 * Sum2_1_1;
	kt2fps1_1_1 = 1.68780000 * Demux1_2_1;
	ManualOverride_Switch1_1_1 = if not(leverThrot_1_2 = 0.0) then EngageORzero_Switch1_1_1 else leverThrot_1_2;
	ManualOverride_Switch1_1_2 = if not(leverThrot_1_2 = 0.0) then EngageORzero_Switch1_1_1 else leverThrot_1_2;
	EngageORzero_LogicalOperator5_1_1 = ATEng_1_1 and (EngageORzero_zero10_1_1 != 0.0);
	EngageORzero_Switch1_1_1 = if (if EngageORzero_LogicalOperator5_1_1 then 1.0 else 0.0) >= 0.50000000 then Sum5_1_1 else EngageORzero_zero9_1_1;
	EngageORzero_zero10_1_1 = 1.00000000;
	EngageORzero_zero9_1_1 = 0.00000000;
	one_1_1 = 1.00000000;
	ThrotCmd_1_1 = ManualOverride_Switch1_1_1;
	ThrotCmd_1_2 = ManualOverride_Switch1_1_2;
tel

node ControlsWithAutopilot_NoBus_PP_Discrete_Fcn_Atomic (LongSensors_1_1 : real; LongSensors_1_2 : real; LongSensors_1_3 : real; LongSensors_1_4 : real; LongSensors_1_5 : real; LongSensors_1_6 : real; LongSensors_1_7 : real; LongSensors_1_8 : real; LongSensors_1_9 : real; LongSensors_1_10 : real; LongSensors_1_11 : real; LongSensors_1_12 : real; LongSensors_1_13 : real; LongSensors_1_14 : real; LongSensors_1_15 : real; LongSensors_1_16 : real; LongSensors_1_17 : real; CmdMan_1_1 : real; CmdMan_1_2 : real; CmdMan_1_3 : real; CmdMan_1_4 : real; CmdMan_1_5 : real; CmdMan_1_6 : real; CmdMan_1_7 : real; CmdMan_1_8 : real; CmdMan_1_9 : real)
returns (Commands_1_1 : real; Commands_1_2 : real; Commands_1_3 : real; Commands_1_4 : real; Commands_1_5 : real; Commands_1_6 : real; Commands_1_7 : real; Commands_1_8 : real; Commands_1_9 : real); 
var
	APAltCmd_1_1 : real;
	APAltEng_1_1 : bool;
	APFPACmd_1_1 : real;
	APFPAEng_1_1 : bool;
	APHdgCmd_1_1 : real;
	APHeadEng_1_1 : bool;
	APThrotEng_1_1 : bool;
	AutoThrottle_1_1 : real; AutoThrottle_1_2 : real;
	CAScmd_1_1 : real;
	Constant3_1_1 : real;
	Constant4_1_1 : real;
	Demux_1_1 : real; Demux_2_1 : real; Demux_3_1 : real; Demux_4_1 : real; Demux_5_1 : real; Demux_6_1 : real; Demux_7_1 : real; Demux_8_1 : real; Demux_9_1 : real; Demux_10_1 : real; Demux_11_1 : real; Demux_12_1 : real; Demux_13_1 : real; Demux_14_1 : real; Demux_15_1 : real; Demux_16_1 : real; Demux_17_1 : real;
	Demux1_1_1 : real; Demux1_1_2 : real; Demux1_1_3 : real; Demux1_2_1 : real; Demux1_2_2 : real; Demux1_3_1 : real; Demux1_3_2 : real; Demux1_4_1 : real; Demux1_4_2 : real;
	Heading_1_1 : real; Heading_1_2 : real;
	Longitudinal_1_1 : real; Longitudinal_1_2 : real; Longitudinal_1_3 : real;
	MachSel_1_1 : real;
	Machcmd_1_1 : real;
	Mux_1_1 : real; Mux_1_2 : real; Mux_1_3 : real; Mux_1_4 : real; Mux_1_5 : real;
	Mux1_1_1 : real; Mux1_1_2 : real; Mux1_1_3 : real; Mux1_1_4 : real; Mux1_1_5 : real; Mux1_1_6 : real; Mux1_1_7 : real; Mux1_1_8 : real; Mux1_1_9 : real;
	YDEngage_1_1 : real;
	YawDamper_1_1 : real; YawDamper_1_2 : real; YawDamper_2_1 : real;
	maxthrot_1_1 : real;
	minthrot_1_1 : real;
	rollLimit_1_1 : real;
	i_virtual_local : real;
let 
	APAltCmd_1_1 = 1.00000000;
	APAltEng_1_1 = true;
	APFPACmd_1_1 = 1.00000000;
	APFPAEng_1_1 = true;
	APHdgCmd_1_1 = 1.00000000;
	APHeadEng_1_1 = true;
	APThrotEng_1_1 = true;
	(AutoThrottle_1_1, AutoThrottle_1_2) = ControlsWithAutopilot_NoBus_PP_Discrete_Fcn_Atomic_AutoThrottle(APThrotEng_1_1, CAScmd_1_1, Machcmd_1_1, MachSel_1_1, Mux_1_1, Mux_1_2, Mux_1_3, Mux_1_4, Mux_1_5, maxthrot_1_1, minthrot_1_1, Demux1_4_1, Demux1_4_2);
	CAScmd_1_1 = 250.00000000;
	Constant3_1_1 = 10.00000000;
	Constant4_1_1 = 3.20000000;
	Demux_1_1 = LongSensors_1_1 ;
	Demux_2_1 = LongSensors_1_2 ;
	Demux_3_1 = LongSensors_1_3 ;
	Demux_4_1 = LongSensors_1_4 ;
	Demux_5_1 = LongSensors_1_5 ;
	Demux_6_1 = LongSensors_1_6 ;
	Demux_7_1 = LongSensors_1_7 ;
	Demux_8_1 = LongSensors_1_8 ;
	Demux_9_1 = LongSensors_1_9 ;
	Demux_10_1 = LongSensors_1_10 ;
	Demux_11_1 = LongSensors_1_11 ;
	Demux_12_1 = LongSensors_1_12 ;
	Demux_13_1 = LongSensors_1_13 ;
	Demux_14_1 = LongSensors_1_14 ;
	Demux_15_1 = LongSensors_1_15 ;
	Demux_16_1 = LongSensors_1_16 ;
	Demux_17_1 = LongSensors_1_17 ;
	Demux1_1_1 = CmdMan_1_1 ;
	Demux1_1_2 = CmdMan_1_2 ;
	Demux1_1_3 = CmdMan_1_3 ;
	Demux1_2_1 = CmdMan_1_4 ;
	Demux1_2_2 = CmdMan_1_5 ;
	Demux1_3_1 = CmdMan_1_6 ;
	Demux1_3_2 = CmdMan_1_7 ;
	Demux1_4_1 = CmdMan_1_8 ;
	Demux1_4_2 = CmdMan_1_9 ;
	(Heading_1_1, Heading_1_2) = ControlsWithAutopilot_NoBus_PP_Discrete_Fcn_Atomic_Heading(APHeadEng_1_1, APHdgCmd_1_1, Demux_9_1, Demux_10_1, Demux_8_1, Demux_11_1, Demux_6_1, Demux_12_1, rollLimit_1_1, Demux1_2_1, Demux1_2_2);
	(Longitudinal_1_1, Longitudinal_1_2, Longitudinal_1_3) = ControlsWithAutopilot_NoBus_PP_Discrete_Fcn_Atomic_Longitudinal(APFPACmd_1_1, APAltEng_1_1, APFPAEng_1_1, APAltCmd_1_1, Demux_1_1, Demux_2_1, Demux_3_1, Demux_4_1, Demux_5_1, Demux_6_1, Demux_7_1, Demux_8_1, Demux1_1_1, Demux1_1_2, Demux1_1_3, Constant4_1_1, Constant3_1_1);
	MachSel_1_1 = 0.00000000;
	Machcmd_1_1 = 0.60000000;
	Mux_1_1 = Demux_9_1 ;
	Mux_1_2 = Demux_6_1 ;
	Mux_1_3 = Demux_14_1 ;
	Mux_1_4 = Demux_8_1 ;
	Mux_1_5 = Demux_15_1 ;
	Mux1_1_1 = Longitudinal_1_1 ;
	Mux1_1_2 = Longitudinal_1_2 ;
	Mux1_1_3 = Longitudinal_1_3 ;
	Mux1_1_4 = Heading_1_1 ;
	Mux1_1_5 = Heading_1_2 ;
	Mux1_1_6 = YawDamper_1_1 ;
	Mux1_1_7 = YawDamper_1_2 ;
	Mux1_1_8 = AutoThrottle_1_1 ;
	Mux1_1_9 = AutoThrottle_1_2 ;
	YDEngage_1_1 = 1.00000000;
	(YawDamper_1_1, YawDamper_1_2, YawDamper_2_1) = ControlsWithAutopilot_NoBus_PP_Discrete_Fcn_Atomic_YawDamper(Demux_13_1, Demux_8_1, Demux1_3_1, Demux1_3_2, YDEngage_1_1);
	maxthrot_1_1 = 100.00000000;
	minthrot_1_1 = 0.00000000;
	rollLimit_1_1 = 30.00000000;
	Commands_1_1 = Mux1_1_1;
	Commands_1_2 = Mux1_1_2;
	Commands_1_3 = Mux1_1_3;
	Commands_1_4 = Mux1_1_4;
	Commands_1_5 = Mux1_1_5;
	Commands_1_6 = Mux1_1_6;
	Commands_1_7 = Mux1_1_7;
	Commands_1_8 = Mux1_1_8;
	Commands_1_9 = Mux1_1_9;
	i_virtual_local= 0.0 -> 1.0;
tel

